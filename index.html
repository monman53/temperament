<meta name="viewport" content="width=device-width, initial-scale=1">

<h1>Temperament</h1>

<canvas height="400" width="400" id="canvas"></canvas>

<fieldset>
<legend>Temperament</legend>
    <label>
    <input type="radio" name="temperament" value="tempered" id="checkbox-tempered" checked/>
    Tempered (A = 440 Hz)
    </label><br>
    <label>
    <input type="radio" name="temperament" value="just-intonation-c" id="checkbox-just-intonation-c" />
    Just intonation (C dur, A = 440 Hz)
    </label>
</fieldset>

<script>
//================================
// Synthesizer (Web Audio API)
//================================

// Create context
window.AudioContext = window.AudioContext || window.webkitAudioContext;
const actx = new AudioContext();

// Create frequency arrays
//   The indices corresponds to MIDI numbers.
//   e.g) 21: A0, 60: C4, 69: A4, 72: C5, 108: C8

// Tempered
const frequenciesTempered = new Array(200);
for (let i = 69; i < 109; i++) {
    frequenciesTempered[i] = 440 * Math.pow(2, 1.0/12 * (i-69));
}
for (let i = 69; i > 20; i--) {
    frequenciesTempered[i] = 440 * Math.pow(2, -1.0/12 * (69-i));
}

// Just intonation
const frequenciesJustIntonationC = new Array(200);
const baseC = 440 * 3 / 5;
frequenciesJustIntonationC[60] = baseC;
frequenciesJustIntonationC[61] = baseC * 16 / 15;
frequenciesJustIntonationC[62] = baseC * 9 / 8;
frequenciesJustIntonationC[63] = baseC * 6 / 5;
frequenciesJustIntonationC[64] = baseC * 5 / 4;
frequenciesJustIntonationC[65] = baseC * 4 / 3;
frequenciesJustIntonationC[66] = baseC * 45 / 32;
frequenciesJustIntonationC[67] = baseC * 3 / 2;
frequenciesJustIntonationC[68] = baseC * 8 / 5;
frequenciesJustIntonationC[69] = baseC * 5 / 3;
frequenciesJustIntonationC[70] = baseC * 7 / 4;
frequenciesJustIntonationC[71] = baseC * 15 / 8;
for (let i = 72; i < 109; i++) {
    frequenciesJustIntonationC[i] = frequenciesJustIntonationC[i - 12] * 2;
}
for (let i = 59; i > 20; i--) {
    frequenciesJustIntonationC[i] = frequenciesJustIntonationC[i + 12] / 2;
}

// Default
const frequencies = new Array(200);
let fluctuationRatio = 0.00005;
// let fluctuationRatio = 0;
const addFluctuation = (freq) => {
    const ratio = fluctuationRatio;
    return freq * (1.0 + ratio * (Math.random() - 0.5));
}
for (let i = 0; i < 200; i++) {
    frequencies[i] = addFluctuation(frequenciesTempered[i])
}

// Keyboard key to MIDI number map
const keys = "qw3e4rt6y7u8io0p-[]" + "azsxdcvgbhnmk,l.;/";
keyToMIDI = {}
for (let i = 0; i < keys.length; i++) {
    keyToMIDI[keys[i]] = 59 + i;
}

// Intermediate nodes for Lissajous curve visualization
const xNode = actx.createGain();
const yNode = actx.createGain();
const analyzerX = actx.createAnalyser();
const analyzerY = actx.createAnalyser();
xNode.connect(analyzerX);
yNode.connect(analyzerY);

// Oscillator instances
const oscillators = {}
let counter = 0;

//--------------------------------
// Keyboard interactions
//--------------------------------
window.addEventListener('keypress', (e) => {
    // Ignoring repeat pressing
    if (e.repeat) {
        return;
    }
    
    // Ignoring unsupported keys
    const MIDIidx = keyToMIDI[e.key];
    if (!MIDIidx) {
        return;
    }

    // Avoiding double allocation
    if (MIDIidx in oscillators){
        return
    }

    // Create an oscillator
    const oscillator = actx.createOscillator();
    oscillator.type = 'sine';
    oscillator.frequency.setValueAtTime(frequencies[MIDIidx], actx.currentTime);

    // Connect to the gain node
    // NOTE: For avoiding distortion
    const amp = actx.createGain();
    amp.gain.value = 0.1;
    oscillator.connect(amp);

    // Connect to the output speaker
    amp.connect(actx.destination);

    // Start oscillator and register
    oscillator.start()
    oscillators[MIDIidx] = oscillator

    // Also connect to the visualization nodes
    // NOTE: Distribute by ping-pong
    if (counter %2 == 0) {
        oscillator.connect(xNode);
    } else {
        oscillator.connect(yNode);
    }
    counter = 1 - counter;
})

window.addEventListener('keyup', (e) => {
    const MIDIidx = keyToMIDI[e.key];
    if (!MIDIidx) {
        return;
    }

    if (!(MIDIidx in oscillators)) {
        return;
    }

    oscillators[MIDIidx].stop();
    delete oscillators[MIDIidx];
})


//================================
// UI controllers
//================================

const checkboxTempered = document.getElementById("checkbox-tempered");
checkboxTempered.addEventListener('change', (e) => {
    for (let i = 0; i < 200; i++) {
        frequencies[i] = addFluctuation(frequenciesTempered[i])
    }
})

const checkboxJustIntonationC = document.getElementById("checkbox-just-intonation-c");
checkboxJustIntonationC.addEventListener('change', (e) => {
    for (let i = 0; i < 200; i++) {
        frequencies[i] = addFluctuation(frequenciesJustIntonationC[i])
    }
})


//================================
// Lissajous curve visualization (WebGL)
//================================

//--------------------------------
// Shaders
//--------------------------------

// Vertex shader
const vertexShader = `#version 300 es

precision highp float;

layout (location = 0) in float x_value;
layout (location = 1) in float y_value;

void main(void) {
  gl_PointSize = 10.0;
  gl_Position = vec4(
    x_value * 0.3,
    y_value * 0.3,
    0.0,
    1.0
  );
}
`;

// Fragment shader
const fragmentShader = `#version 300 es

precision highp float;

out vec4 o_color;

uniform vec3 u_color;

void main(void) {
  // Green
  o_color = vec4(0.4, 1.0, 0.4, 1.0);
}
`;

//--------------------------------
// Support functions for WebGL
//--------------------------------

function createShader(gl, source, type) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    throw new Error(gl.getShaderInfoLog(shader) + source);
  }
  return shader;
}

function createProgram(gl, vertShader, fragShader) {
  const program = gl.createProgram();
  gl.attachShader(program, vertShader);
  gl.attachShader(program, fragShader);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    throw new Error(gl.getProgramInfoLog(program));
  }
  return program;
}

function createVbo(gl, array, usage) {
  const vbo = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
  gl.bufferData(gl.ARRAY_BUFFER, array, usage);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);
  return vbo;
}

//--------------------------------
// WebGL setup
//--------------------------------

const canvas = document.getElementById("canvas");
const gl = canvas.getContext('webgl2');
gl.clearColor(0.0, 0.0, 0.0, 1.0);
const program = createProgram(gl,
    createShader(gl, vertexShader, gl.VERTEX_SHADER),
    createShader(gl, fragmentShader, gl.FRAGMENT_SHADER));

// Buffers
const xArray = new Float32Array(analyzerX.fftSize);
const yArray = new Float32Array(analyzerY.fftSize);
const xArrayVbo = createVbo(gl, xArray, gl.DYNAMIC_DRAW);
const yArrayVbo = createVbo(gl, yArray, gl.DYNAMIC_DRAW);

// Render callback
let frames = 0;
let startTime = new Date().getTime();
const render = () => {
    // Calculate FPS
    frames += 1;
    let endTime = new Date().getTime();
    if (endTime - startTime >= 1000) {
        // fps.innerText = frames / (endTime - startTime) * 1000;
        startTime = endTime;
        frames = 0;
    }

    // Getting current waves
    analyzerX.getFloatTimeDomainData(xArray);
    analyzerY.getFloatTimeDomainData(yArray);

    // Canvas rendering
    gl.useProgram(program);

    // Binding x-coordinates array
    gl.bindBuffer(gl.ARRAY_BUFFER, xArrayVbo);
    gl.bufferSubData(gl.ARRAY_BUFFER, 0, xArray);
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0, 1, gl.FLOAT, false, 0, 0);

    // Binding x-coordinates array
    gl.bindBuffer(gl.ARRAY_BUFFER, yArrayVbo);
    gl.bufferSubData(gl.ARRAY_BUFFER, 0, yArray);
    gl.enableVertexAttribArray(1);
    gl.vertexAttribPointer(1, 1, gl.FLOAT, false, 0, 0);

    // Draw lines
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.drawArrays(gl.LINE_STRIP, 0, xArray.length);

    // Next frame
    requestAnimationFrame(render);
}

// Rendering bootstrap
requestAnimationFrame(render);

</script>