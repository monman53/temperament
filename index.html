<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Temperament Lissajous</title>

<div id="app">
    <canvas width="400" height="400" id="canvas"></canvas>
    </br>

    <svg width="400" height="200">
        <g v-for="(item, index) in keyboard">
            <rect :width="keyboardWidth(item, keyboardPitch)" :height="keyboardHeight(item, 180, 100)"
                :x="keyboardX(item, keyboard[0], keyboardPitch)" y="5" :fill="keyboardFill(item, isNoteOn[item])"
                stroke="black" @click="noteToggle(item)" />
        </g>
        <g v-for="(item, index) in keyboard">
            <g v-if="isBlackKey(item)">
                <rect :width="keyboardWidth(item, keyboardPitch)" :height="keyboardHeight(item, 180, 100)"
                    :x="keyboardX(item, keyboard[0], keyboardPitch)" y="5" :fill="keyboardFill(item, isNoteOn[item])"
                    stroke="black" @click="noteToggle(item)" />
            </g>
        </g>
    </svg>

    <fieldset @click="resetNote()">
        <legend>Temperament</legend>
        <label>
            <input type="radio" name="temperament" value="tempered" v-model="temperament" />
            Tempered (A = 440 Hz)
        </label>
        </br>
        <label>
            <input type="radio" name="temperament" value="just-intonation-c" v-model="temperament" />
            Just intonation (C dur, A = 440 Hz)
        </label>
    </fieldset>
    <fieldset>
        <legend>Options</legend>
        <label>
            <input type="checkbox" v-model="useFluctuation">
            Fluctuation
        </label>
    </fieldset>
    <fieldset>
        <legend>Info</legend>
        <ul>
            <li>Temperament: {{ temperament }}</li>
            <li>useFluctuation: {{ useFluctuation }}</li>
            <li>fps: {{ fps }}</li>
        </ul>
    </fieldset>
</div>

<script type="x-shader/x-vertex" id="vertex-shader">#version 300 es
    precision highp float;

    layout (location = 0) in float x_value;
    layout (location = 1) in float y_value;

    out float intensity;

    void main(void) {
        intensity = sqrt(float(gl_VertexID) / 2048.0);
        gl_PointSize = 10.0;
        gl_Position = vec4(
            x_value * 0.3,
            y_value * 0.3,
            0.0,
            1.0
        );
    }
</script>

<script type="x-shader/x-fragment" id="fragment-shader">#version 300 es
    precision highp float;

    in float intensity;
    out vec4 fragColor;

    void main(void) {
        // Green
        vec3 green = vec3(0.4, 1.0, 0.6) * intensity;
        fragColor = vec4(green, 1.0);
    }
</script>

<script type="module">
    //================================
    // Synthesizer (Web Audio API)
    //================================

    // Create context
    window.AudioContext = window.AudioContext || window.webkitAudioContext;
    const actx = new AudioContext();

    // Create frequency arrays
    //   The indices corresponds to MIDI numbers.
    //   e.g) 21: A0, 60: C4, 69: A4, 72: C5, 108: C8

    // Tempered
    const frequenciesTempered = new Array(200);
    for (let i = 69; i < 109; i++) {
        frequenciesTempered[i] = 440 * Math.pow(2, 1.0 / 12 * (i - 69));
    }
    for (let i = 69; i > 20; i--) {
        frequenciesTempered[i] = 440 * Math.pow(2, -1.0 / 12 * (69 - i));
    }

    // Just intonation
    const frequenciesJustIntonationC = new Array(200);
    const baseC = 440 * 3 / 5;
    frequenciesJustIntonationC[60] = baseC;
    frequenciesJustIntonationC[61] = baseC * 16 / 15;
    frequenciesJustIntonationC[62] = baseC * 9 / 8;
    frequenciesJustIntonationC[63] = baseC * 6 / 5;
    frequenciesJustIntonationC[64] = baseC * 5 / 4;
    frequenciesJustIntonationC[65] = baseC * 4 / 3;
    frequenciesJustIntonationC[66] = baseC * 45 / 32;
    frequenciesJustIntonationC[67] = baseC * 3 / 2;
    frequenciesJustIntonationC[68] = baseC * 8 / 5;
    frequenciesJustIntonationC[69] = baseC * 5 / 3;
    frequenciesJustIntonationC[70] = baseC * 7 / 4;
    frequenciesJustIntonationC[71] = baseC * 15 / 8;
    for (let i = 72; i < 109; i++) {
        frequenciesJustIntonationC[i] = frequenciesJustIntonationC[i - 12] * 2;
    }
    for (let i = 59; i > 20; i--) {
        frequenciesJustIntonationC[i] = frequenciesJustIntonationC[i + 12] / 2;
    }

    // Keyboard key to MIDI number map
    const keys = "qw3e4rt6y7u8io0p-[]" + "azsxdcvgbhnmk,l.;/";
    const keyToMIDI = {}
    for (let i = 0; i < keys.length; i++) {
        keyToMIDI[keys[i]] = 59 + i;
    }

    // Oscillator instances
    const oscillators = {}

    // Intermediate nodes for Lissajous curve visualization
    const xNode = actx.createGain();
    const yNode = actx.createGain();
    const analyzerX = actx.createAnalyser();
    const analyzerY = actx.createAnalyser();
    const fftSize = 1 << 11;
    analyzerX.fftSize = fftSize;
    analyzerY.fftSize = fftSize;
    xNode.connect(analyzerX);
    yNode.connect(analyzerY);

    //================================
    // Lissajous curve visualization (WebGL)
    //================================

    //--------------------------------
    // Shaders
    //--------------------------------

    // Vertex shader
    const vertexShader = document.querySelector("#vertex-shader").innerHTML;

    // Fragment shader
    const fragmentShader = document.querySelector("#fragment-shader").innerHTML;

    //--------------------------------
    // Support functions for WebGL
    //--------------------------------

    function createShader(gl, source, type) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            throw new Error(gl.getShaderInfoLog(shader) + source);
        }
        return shader;
    }

    function createProgram(gl, vertShader, fragShader) {
        const program = gl.createProgram();
        gl.attachShader(program, vertShader);
        gl.attachShader(program, fragShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            throw new Error(gl.getProgramInfoLog(program));
        }
        return program;
    }

    function createVbo(gl, array, usage) {
        const vbo = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
        gl.bufferData(gl.ARRAY_BUFFER, array, usage);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        return vbo;
    }

    import { createApp } from 'https://unpkg.com/vue@3/dist/vue.esm-browser.js'

    createApp({
        data() {
            return {
                message: 'Hello Vue!',
                temperament: 'tempered',
                useFluctuation: false,
                count: 0,
                fps: 0,
                fftSize: 2048,
                keyboard: [60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72],
                isNoteOn: Array(200).fill(false),
                keyboardPitch: 16,
            }
        },
        methods: {
            keyboardX(keyId, start, pitch) {
                const offset = 21 * pitch * (Math.floor((keyId - start) / 12));
                switch (keyId % 12) {
                    case 0:
                        return offset + pitch * 0;
                    case 1:
                        return offset + pitch * 2;
                    case 2:
                        return offset + pitch * 3;
                    case 3:
                        return offset + pitch * 5;
                    case 4:
                        return offset + pitch * 6;
                    case 5:
                        return offset + pitch * 9;
                    case 6:
                        return offset + pitch * 11;
                    case 7:
                        return offset + pitch * 12;
                    case 8:
                        return offset + pitch * 14;
                    case 9:
                        return offset + pitch * 15;
                    case 10:
                        return offset + pitch * 17;
                    case 11:
                        return offset + pitch * 18;
                }
            },
            isBlackKey(keyId) {
                switch (keyId % 12) {
                    case 1:
                    case 3:
                    case 6:
                    case 8:
                    case 10:
                        return true;
                    default:
                        return false;
                }
            },
            keyboardFill(keyId, pressed) {
                if (pressed) {
                    return "gray";
                } else {
                    return this.isBlackKey(keyId) ? "black" : "white";
                }
            },
            keyboardHeight(keyId, heightWhite, heightBlack) {
                return this.isBlackKey(keyId) ? heightBlack : heightWhite;
            },
            keyboardWidth(keyId, pitch) {
                switch (keyId % 12) {
                    case 1:
                    case 3:
                    case 6:
                    case 8:
                    case 10:
                        return pitch * 2;
                    default:
                        return pitch * 3;
                }
            },
            noteOn(key) {
                const MIDIidx = key;

                // Avoiding double allocation
                if (MIDIidx in oscillators) {
                    return
                }

                // Create an oscillator
                const frequency = this.frequencies[MIDIidx];
                const oscillator = actx.createOscillator();
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(frequency, actx.currentTime);

                // Connect to the gain node
                // NOTE: For avoiding distortion
                const amp = actx.createGain();
                amp.gain.value = Math.min(0.1 * 440 / frequency, 0.2);
                oscillator.connect(amp);

                // Connect to the output speaker
                amp.connect(actx.destination);

                // Start oscillator and register
                oscillator.start()
                oscillators[MIDIidx] = oscillator
                this.isNoteOn[MIDIidx] = true;

                // Also connect to the visualization nodes
                const pressedNotes = Object.keys(oscillators).length;
                if (pressedNotes % 2 == 0) {
                    oscillator.connect(xNode);
                } else {
                    oscillator.connect(yNode);
                }
            },
            noteOff(key) {
                const MIDIidx = key;

                if (!(MIDIidx in oscillators)) {
                    return;
                }

                oscillators[MIDIidx].stop();
                delete oscillators[MIDIidx];
                this.isNoteOn[MIDIidx] = false;
            },
            noteToggle(key) {
                if (this.isNoteOn[key]) {
                    this.noteOff(key);
                } else {
                    this.noteOn(key);
                }
            },
            resetNote() {
                for (let i = 0; i < 200; i++) {
                    this.noteOff(i);
                }
            }
        },
        computed: {
            frequencies() {
                // Default
                const fs = new Array(200);
                const source = this.temperament === "tempered" ? frequenciesTempered : frequenciesJustIntonationC;
                let fluctuationRatio = this.useFluctuation ? 0.00005 : 0.0;
                const addFluctuation = (freq) => {
                    const ratio = fluctuationRatio;
                    return freq * (1.0 + ratio * (Math.random() - 0.5));
                }
                for (let i = 0; i < 200; i++) {
                    fs[i] = addFluctuation(source[i])
                }
                return fs;
            }
        },
        mounted() {

            //--------------------------------
            // Keyboard interactions
            //--------------------------------
            window.addEventListener('keypress', (e) => {
                // Ignoring repeat pressing
                if (e.repeat) {
                    return;
                }

                // Ignoring unsupported keys
                const MIDIidx = keyToMIDI[e.key];
                if (!MIDIidx) {
                    return;
                }

                this.noteOn(MIDIidx);
            })

            window.addEventListener('keyup', (e) => {
                const MIDIidx = keyToMIDI[e.key];
                if (!MIDIidx) {
                    return;
                }

                this.noteOff(MIDIidx);
            })

            //================================
            // MIDI input handlers (Web MIDI API)
            //================================

            const getMIDIMessage = (message) => {
                var command = message.data[0];
                var key = message.data[1];

                // noteOn
                if (144 <= command && command <= 159) {
                    this.noteOn(key);
                }

                // noteOff
                if (128 <= command && command <= 143) {
                    this.noteOff(key);
                }
            }

            if (navigator.requestMIDIAccess) {
                console.log('This browser supports WebMIDI!');
            } else {
                console.log('WebMIDI is not supported in this browser.');
            }

            const onMIDISuccess = (midiAccess) => {
                for (var input of midiAccess.inputs.values()) {
                    input.onmidimessage = getMIDIMessage;
                }
            }

            const onMIDIFailure = () => {
                console.log('Could not access your MIDI devices.');
            }

            navigator.requestMIDIAccess()
                .then(onMIDISuccess, onMIDIFailure);

            //--------------------------------
            // WebGL setup
            //--------------------------------
            const canvas = document.getElementById("canvas");
            const gl = canvas.getContext('webgl2');
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            const program = createProgram(gl,
                createShader(gl, vertexShader, gl.VERTEX_SHADER),
                createShader(gl, fragmentShader, gl.FRAGMENT_SHADER));

            // Buffers
            const xArray = new Float32Array(this.fftSize);
            const yArray = new Float32Array(this.fftSize);
            const xArrayVbo = createVbo(gl, xArray, gl.DYNAMIC_DRAW);
            const yArrayVbo = createVbo(gl, yArray, gl.DYNAMIC_DRAW);

            // Render callback
            let frames = 0;
            let startTime = new Date().getTime();
            const render = () => {
                // Calculate FPS
                frames += 1;
                let endTime = new Date().getTime();
                if (endTime - startTime >= 1000) {
                    this.fps = frames / (endTime - startTime) * 1000;
                    startTime = endTime;
                    frames = 0;
                }

                // Getting current waves
                analyzerX.getFloatTimeDomainData(xArray);
                analyzerY.getFloatTimeDomainData(yArray);

                // Canvas rendering
                gl.useProgram(program);

                // Binding x-coordinates array
                gl.bindBuffer(gl.ARRAY_BUFFER, xArrayVbo);
                gl.bufferSubData(gl.ARRAY_BUFFER, 0, xArray);
                gl.enableVertexAttribArray(0);
                gl.vertexAttribPointer(0, 1, gl.FLOAT, false, 0, 0);

                // Binding x-coordinates array
                gl.bindBuffer(gl.ARRAY_BUFFER, yArrayVbo);
                gl.bufferSubData(gl.ARRAY_BUFFER, 0, yArray);
                gl.enableVertexAttribArray(1);
                gl.vertexAttribPointer(1, 1, gl.FLOAT, false, 0, 0);

                // Draw lines
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.lineWidth(2.0);
                gl.drawArrays(gl.LINE_STRIP, 0, xArray.length);

                // Next frame
                requestAnimationFrame(render);
            }

            // Rendering bootstrap
            requestAnimationFrame(render);
        },
    }).mount('#app')
</script>